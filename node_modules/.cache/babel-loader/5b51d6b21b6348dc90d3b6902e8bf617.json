{"ast":null,"code":"import * as React from 'react';\nimport { useRef, useEffect, cloneElement } from 'react';\nimport { usePreferencesEditor, PreferenceKeyContextProvider, useTranslate } from 'ra-core';\nimport { alpha, Badge } from '@mui/material';\nimport { styled } from '@mui/material/styles';\nimport SettingsIcon from '@mui/icons-material/Settings';\nimport clsx from 'clsx';\n/**\n * Wrap any component with this component to make it configurable\n *\n * When the edit mode is enabled, users will see a button to edit the component;\n * when clicked, the inspector will show the editor element.\n *\n * Creates a context for the preference key, so that both the child component\n * and the editor can access it using usePreferenceKey();\n *\n * @example\n * const ConfigurableTextBlock = ({ preferenceKey = \"TextBlock\", ...props }) => (\n *     <Configurable editor={<TextBlockInspector />} preferenceKey={preferenceKey}>\n *         <TextBlock {...props} />\n *     </Configurable>\n * );\n */\nexport var Configurable = function (props) {\n  var children = props.children,\n    editor = props.editor,\n    preferenceKey = props.preferenceKey,\n    _a = props.openButtonLabel,\n    openButtonLabel = _a === void 0 ? 'ra.configurable.customize' : _a,\n    sx = props.sx;\n  var prefixedPreferenceKey = \"preferences.\".concat(preferenceKey);\n  var preferencesEditorContext = usePreferencesEditor();\n  var hasPreferencesEditorContext = !!preferencesEditorContext;\n  var translate = useTranslate();\n  var _b = preferencesEditorContext || {},\n    isEnabled = _b.isEnabled,\n    setEditor = _b.setEditor,\n    currentPreferenceKey = _b.preferenceKey,\n    setPreferenceKey = _b.setPreferenceKey;\n  var isEditorOpen = prefixedPreferenceKey === currentPreferenceKey;\n  var editorOpenRef = useRef(isEditorOpen);\n  useEffect(function () {\n    editorOpenRef.current = isEditorOpen;\n  }, [isEditorOpen]);\n  // on unmount, if selected, remove the editor\n  useEffect(function () {\n    return function () {\n      if (!editorOpenRef.current) return;\n      setPreferenceKey && setPreferenceKey(null);\n      setEditor && setEditor(null);\n    };\n  }, [setEditor, setPreferenceKey]);\n  if (!hasPreferencesEditorContext) {\n    return children;\n  }\n  var handleOpenEditor = function () {\n    // include the editorKey as key to force destroy and mount\n    // when switching between two identical editors with different editor keys\n    // otherwise the editor will see an update and its useStore will return one tick later\n    // which would forbid the usage of uncontrolled inputs in the editor\n    setEditor(cloneElement(editor, {\n      preferenceKey: prefixedPreferenceKey,\n      key: prefixedPreferenceKey\n    }));\n    // as we modify the editor, isEditorOpen cannot compare the editor element\n    // we'll compare the editor key instead\n    setPreferenceKey(prefixedPreferenceKey);\n  };\n  return React.createElement(PreferenceKeyContextProvider, {\n    value: prefixedPreferenceKey\n  }, React.createElement(Root, {\n    className: clsx(isEnabled && ConfigurableClasses.editMode, isEditorOpen && ConfigurableClasses.editorActive),\n    sx: sx\n  }, React.createElement(Badge, {\n    badgeContent: React.createElement(SettingsIcon\n    // @ts-ignore\n    , {\n      // @ts-ignore\n      fontSize: \"12px\"\n    }),\n    componentsProps: {\n      badge: {\n        title: translate(openButtonLabel),\n        onClick: handleOpenEditor\n      }\n    },\n    color: \"warning\",\n    invisible: !isEnabled\n  }, children)));\n};\nvar PREFIX = 'RaConfigurable';\nexport var ConfigurableClasses = {\n  editMode: \"\".concat(PREFIX, \"-editMode\"),\n  button: \"\".concat(PREFIX, \"-button\"),\n  editorActive: \"\".concat(PREFIX, \"-editorActive\")\n};\nvar Root = styled('span', {\n  name: PREFIX,\n  overridesResolver: function (props, styles) {\n    return styles.root;\n  }\n})(function (_a) {\n  var _b;\n  var theme = _a.theme;\n  return _b = {}, _b[\"& .MuiBadge-badge\"] = {\n    visibility: 'hidden',\n    pointerEvents: 'none',\n    padding: 0\n  }, _b[\"&.\".concat(ConfigurableClasses.editMode, \":hover > .MuiBadge-root > .MuiBadge-badge\")] = {\n    visibility: 'visible',\n    pointerEvents: 'initial',\n    cursor: 'pointer'\n  }, _b[\"&.\".concat(ConfigurableClasses.editMode, \" > .MuiBadge-root > :not(.MuiBadge-badge)\")] = {\n    transition: theme.transitions.create('outline'),\n    outline: \"\".concat(alpha(theme.palette.warning.main, 0.3), \" solid 2px\")\n  }, _b[\"&.\".concat(ConfigurableClasses.editMode, \":hover > .MuiBadge-root > :not(.MuiBadge-badge)\")] = {\n    outline: \"\".concat(alpha(theme.palette.warning.main, 0.5), \" solid 2px\")\n  }, _b[\"&.\".concat(ConfigurableClasses.editMode, \".\").concat(ConfigurableClasses.editorActive, \" > .MuiBadge-root > :not(.MuiBadge-badge), &.\").concat(ConfigurableClasses.editMode, \".\").concat(ConfigurableClasses.editorActive, \":hover > .MuiBadge-root > :not(.MuiBadge-badge)\")] = {\n    outline: \"\".concat(theme.palette.warning.main, \" solid 2px\")\n  }, _b;\n});","map":{"version":3,"mappings":"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","names":["React","useRef","useEffect","cloneElement","usePreferencesEditor","PreferenceKeyContextProvider","useTranslate","alpha","Badge","styled","SettingsIcon","clsx","Configurable","props","editor","preferenceKey","_a","openButtonLabel","sx","prefixedPreferenceKey","preferencesEditorContext","hasPreferencesEditorContext","translate","isEnabled","setEditor","currentPreferenceKey","setPreferenceKey","isEditorOpen","editorOpenRef","current","children","handleOpenEditor","key","value","Root","className","ConfigurableClasses","editMode","editorActive","badgeContent","fontSize","componentsProps","badge","title","onClick","color","invisible","PREFIX","button","name","overridesResolver","styles","root","theme","_b","visibility","pointerEvents","padding","cursor","transition","transitions","create","outline","palette","warning","main"],"sources":["/Users/jjun/design_system/node_modules/ra-ui-materialui/src/preferences/Configurable.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useRef, useEffect, cloneElement, ReactElement } from 'react';\nimport {\n    usePreferencesEditor,\n    PreferenceKeyContextProvider,\n    useTranslate,\n} from 'ra-core';\nimport { alpha, Badge } from '@mui/material';\nimport { styled, SxProps } from '@mui/material/styles';\nimport SettingsIcon from '@mui/icons-material/Settings';\nimport clsx from 'clsx';\n\n/**\n * Wrap any component with this component to make it configurable\n *\n * When the edit mode is enabled, users will see a button to edit the component;\n * when clicked, the inspector will show the editor element.\n *\n * Creates a context for the preference key, so that both the child component\n * and the editor can access it using usePreferenceKey();\n *\n * @example\n * const ConfigurableTextBlock = ({ preferenceKey = \"TextBlock\", ...props }) => (\n *     <Configurable editor={<TextBlockInspector />} preferenceKey={preferenceKey}>\n *         <TextBlock {...props} />\n *     </Configurable>\n * );\n */\nexport const Configurable = (props: ConfigurableProps) => {\n    const {\n        children,\n        editor,\n        preferenceKey,\n        openButtonLabel = 'ra.configurable.customize',\n        sx,\n    } = props;\n\n    const prefixedPreferenceKey = `preferences.${preferenceKey}`;\n    const preferencesEditorContext = usePreferencesEditor();\n    const hasPreferencesEditorContext = !!preferencesEditorContext;\n\n    const translate = useTranslate();\n\n    const {\n        isEnabled,\n        setEditor,\n        preferenceKey: currentPreferenceKey,\n        setPreferenceKey,\n    } = preferencesEditorContext || {};\n\n    const isEditorOpen = prefixedPreferenceKey === currentPreferenceKey;\n    const editorOpenRef = useRef(isEditorOpen);\n\n    useEffect(() => {\n        editorOpenRef.current = isEditorOpen;\n    }, [isEditorOpen]);\n\n    // on unmount, if selected, remove the editor\n    useEffect(() => {\n        return () => {\n            if (!editorOpenRef.current) return;\n            setPreferenceKey && setPreferenceKey(null);\n            setEditor && setEditor(null);\n        };\n    }, [setEditor, setPreferenceKey]);\n\n    if (!hasPreferencesEditorContext) {\n        return children;\n    }\n\n    const handleOpenEditor = () => {\n        // include the editorKey as key to force destroy and mount\n        // when switching between two identical editors with different editor keys\n        // otherwise the editor will see an update and its useStore will return one tick later\n        // which would forbid the usage of uncontrolled inputs in the editor\n        setEditor(\n            cloneElement(editor, {\n                preferenceKey: prefixedPreferenceKey,\n                key: prefixedPreferenceKey,\n            })\n        );\n        // as we modify the editor, isEditorOpen cannot compare the editor element\n        // we'll compare the editor key instead\n        setPreferenceKey(prefixedPreferenceKey);\n    };\n\n    return (\n        <PreferenceKeyContextProvider value={prefixedPreferenceKey}>\n            <Root\n                className={clsx(\n                    isEnabled && ConfigurableClasses.editMode,\n                    isEditorOpen && ConfigurableClasses.editorActive\n                )}\n                sx={sx}\n            >\n                <Badge\n                    badgeContent={\n                        <SettingsIcon\n                            // @ts-ignore\n                            fontSize=\"12px\"\n                        />\n                    }\n                    componentsProps={{\n                        badge: {\n                            title: translate(openButtonLabel),\n                            onClick: handleOpenEditor,\n                        },\n                    }}\n                    color=\"warning\"\n                    invisible={!isEnabled}\n                >\n                    {children}\n                </Badge>\n            </Root>\n        </PreferenceKeyContextProvider>\n    );\n};\n\nexport interface ConfigurableProps {\n    children: ReactElement;\n    editor: ReactElement;\n    preferenceKey: string;\n    openButtonLabel?: string;\n    sx?: SxProps;\n}\n\nconst PREFIX = 'RaConfigurable';\n\nexport const ConfigurableClasses = {\n    editMode: `${PREFIX}-editMode`,\n    button: `${PREFIX}-button`,\n    editorActive: `${PREFIX}-editorActive`,\n};\n\nconst Root = styled('span', {\n    name: PREFIX,\n    overridesResolver: (props, styles) => styles.root,\n})(({ theme }) => ({\n    [`& .MuiBadge-badge`]: {\n        visibility: 'hidden',\n        pointerEvents: 'none',\n        padding: 0,\n    },\n    [`&.${ConfigurableClasses.editMode}:hover > .MuiBadge-root > .MuiBadge-badge`]: {\n        visibility: 'visible',\n        pointerEvents: 'initial',\n        cursor: 'pointer',\n    },\n    [`&.${ConfigurableClasses.editMode} > .MuiBadge-root > :not(.MuiBadge-badge)`]: {\n        transition: theme.transitions.create('outline'),\n        outline: `${alpha(theme.palette.warning.main, 0.3)} solid 2px`,\n    },\n    [`&.${ConfigurableClasses.editMode}:hover > .MuiBadge-root > :not(.MuiBadge-badge)`]: {\n        outline: `${alpha(theme.palette.warning.main, 0.5)} solid 2px`,\n    },\n\n    [`&.${ConfigurableClasses.editMode}.${ConfigurableClasses.editorActive} > .MuiBadge-root > :not(.MuiBadge-badge), &.${ConfigurableClasses.editMode}.${ConfigurableClasses.editorActive}:hover > .MuiBadge-root > :not(.MuiBadge-badge)`]: {\n        outline: `${theme.palette.warning.main} solid 2px`,\n    },\n}));\n"]},"metadata":{},"sourceType":"module"}